#!/usr/bin/env python
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)
import h5py
import os
import datetime

__version__ = "0.0.1"

shareddirlist = []
reduceloglist = []


class GenericFile(object):
    def __init__(self, path):
        self.filename = path
        self.timeCreation = None
        self.filesize = 0.

        if self.filename is None:
            return
        if not os.path.exists(self.filename):
            return

        stat = os.stat(self.filename)
        self.timeCreation = datetime.datetime.fromtimestamp(stat.st_ctime)
        self.filesize = stat.st_size

    def __bool__(self):
        if self.filename is None:
            return False
        return os.path.exists(self.filename)

    def iso8601(self):
        if self.timeCreation is None:
            return ''
        else:
            return self.timeCreation.strftime("%Y-%m-%dT%H:%M")

    def filesizehuman(self):
        if self.filesize < 1024:
            return "%dB" % (self.filesize)

        filesize_converted = float(self.filesize) / 1024.  # to kiB
        if filesize_converted < 1024.:
            return "%.1fkiB" % (filesize_converted)

        filesize_converted = float(filesize_converted) / 1024.  # to MiB
        if filesize_converted < 1024.:
            return "%.1fMiB" % (filesize_converted)

        filesize_converted = float(filesize_converted) / 1024.  # to GiB
        return "%.1fGiB" % (filesize_converted)


class ReductionLogFile(GenericFile):
    def __init__(self, direc, logname):
        super(ReductionLogFile, self).__init__(os.path.join(direc, logname))
        self.mantidVersion = "UNKNOWN"
        self.longestDuration = 0.
        self.longestAlgorithm = ""
        self.loadDurationTotal = 0.
        self.started = ''
        self.host = ''

        if not bool(self):  # something wrong with the log

            return

        self.__findMantidVersion()

        self.__findLongestDuration()
        self.longestDuration = "%.1f" % self.longestDuration
        # self.longestDuration = __class__.durationToHuman(self.longestDuration)

        self.__findLoadTotal()
        self.loadDurationTotal = "%.1f" % self.loadDurationTotal

    def durationToHuman(duration):
        (hours, minutes, seconds) = (0., 0., duration)
        if seconds > 60.:
            minutes = int(seconds / 60.)
            seconds = seconds % 60
            if minutes > 60:
                hours = int(minutes / 60)
                minutes = minutes % 60
        return "%dh%02dm%02ds" % (hours, minutes, int(seconds))

    def __findLoadTotal(self):
        self.loadDurationTotal = 0.

        with open(self.filename, 'r') as handle:
            for line in handle:
                if "Duration" not in line:
                    continue
                if "-1 seconds" in line:
                    continue
                if "Load" not in line:
                    continue
                line = line.strip()
                (_, duration) \
                    = self.logDurationToNameAndSeconds(line)
                self.loadDurationTotal += duration

    @staticmethod
    def logDurationToNameAndSeconds(line):
        line = line.split()
        algorithm = line[1]
        duration = line[4:]

        if len(duration) == 2:  # only seconds
            duration = float(duration[0])
        elif len(duration) == 4:  # minutes and seconds
            duration = float(duration[0]) * 60. \
                       + float(duration[2])
        else:
            raise RuntimeError("Don't know how to parse duration")
        return (algorithm, duration)

    def __findLongestDuration(self):
        self.longestDuration = 0.  # in seconds

        with open(self.filename, 'r') as handle:
            for line in handle:
                if "Duration" in line:
                    line = line.strip()
                    if "-1 seconds" in line:
                        continue
                    (algorithm, duration) \
                        = self.logDurationToNameAndSeconds(line)

                    if duration > self.longestDuration:
                        self.longestDuration = duration
                        self.longestAlgorithm = algorithm

    def __findMantidVersion(self):
        with open(self.filename, 'r') as handle:
            for line in handle:
                line = line.strip()
                if "This is Mantid version" in line:
                    self.mantidVersion = line.split()[5]
                if "running" in line and "starting" in line:
                    (self.host, _, self.started) = line.split()[2:]


class ARstatus:
    def __init__(self, direc, eventfile):
        self.eventfile = eventfile
        self.reduxfiles = [os.path.join(direc, name)
                           for name in shareddirlist
                           if eventfile.isThisRun(name)]

        logdir = os.path.join(direc, 'reduction_log')
        self.logfile = ReductionLogFile(logdir, eventfile.shortname + ".log")
        self.errfile = ReductionLogFile(logdir, eventfile.shortname + ".err")

    def hasLog(self):
        return (bool(self.logfile) or bool(self.errfile))

    @staticmethod
    def header():
        return ("runID", "runStart", "runStop", "runCTime", "eventSize",
                "host", "numReduced", "version", "reduxStart",
                "logCTime", "longAlgo", "algoDuration", "loadDurationTotal")

    def report(self):
        return (str(self.eventfile),
                self.eventfile.timeStart, self.eventfile.timeStop,
                self.eventfile.iso8601(),
                self.eventfile.filesizehuman(),
                self.logfile.host,
                str(len(self.reduxfiles)), self.logfile.mantidVersion,
                self.logfile.started,
                self.logfile.iso8601(),
                self.logfile.longestAlgorithm, self.logfile.longestDuration,
                self.logfile.loadDurationTotal)


class EventFile(GenericFile):
    def __init__(self, direc, filename):
        super(EventFile, self).__init__(os.path.join(direc, filename))
        self.shortname = filename
        self.prefix = filename.replace('.nxs.h5', '').replace('_event.nxs', '')

        with h5py.File(self.filename, 'r') as handle:
            entry = handle.get("entry")
            self.timeStart = entry.get("start_time").value[0].decode('utf-8')[:16]
            self.timeStop = entry.get("end_time").value[0].decode('utf-8')[:16]

    def __str__(self):
        return self.prefix

    def __repr__(self):
        return self.prefix

    def isThisRun(self, filename):
        return filename.startswith(self.prefix)


def getRuns(propdir):
    # find the data directory
    datadirs = [os.path.join(propdir, subdir) for subdir in ['data', 'nexus']]
    datadirs = [direc for direc in datadirs if os.path.isdir(direc)]
    if len(datadirs) != 1:
        raise RuntimeError("Expected only one data directory, found " \
                           + ','.join(datadirs))

    # get a list of event files in that directory
    files = os.listdir(datadirs[0])
    files = [name for name in files if not name.endswith("_histo.nxs")]
    files = [EventFile(datadirs[0], name) for name in files]

    return files


def getOutFilename(propdir):
    (parent, prop) = os.path.split(propdir)
    (parten, inst) = os.path.split(parent)
    return "%s-%s.csv" % (inst, prop)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Report information on ' \
                                                 + 'auto-reduction in a proposal')
    parser.add_argument('-p', '--propdir', metavar="IPTSDIR",
                        help="proposal directory to report on")
    parser.add_argument('-r', '--runfile', metavar="NEXUSFILE",
                        help="path to a nexus file, changes to append")
    parser.add_argument('-o', '--outputdir',
                        help="directory to write csv to, " \
                             + "defaults to instrument shared")
    args = parser.parse_args()

    if args.propdir is None:
        pass
    else:
        pass

    args.propdir = os.path.abspath(args.propdir)

    if not os.path.exists(args.propdir):
        parser.error("Proposal directory does not exist")
    if not os.path.isdir(args.propdir):
        parser.error("Specified a file rather than a directory")

    print("Finding event nexus files in '%s'" % args.propdir)
    runs = getRuns(args.propdir)
    reducedir = os.path.join(args.propdir, 'shared', 'autoreduce')
    shareddirlist = os.listdir(reducedir)

    outfile = getOutFilename(args.propdir)
    print("Writing results to '%s'" % outfile)
    total_runs = len(runs)
    total_reduced = 0
    with open(outfile, 'w') as handle:
        handle.write(','.join(ARstatus.header()) + "\n")
        for eventfile in runs:
            ar = ARstatus(reducedir, eventfile)
            report = [str(item) for item in ar.report()]
            if len(ar.reduxfiles) > 0:
                total_reduced += 1
            handle.write(','.join(report) + "\n")
    print("%d of %d files reduced" % (total_reduced, total_runs))
